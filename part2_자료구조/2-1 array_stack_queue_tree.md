# Array  vs  Linked List

1. Array

   - 가장 기본적인 자료구조인 Array 자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 __인덱스__로 해당 원소에 접근가능.
   - 하지만 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에 시간이 더 걸림. 그리고 배열에서 삭제가 발생할 때, 배열의 연속적인 특징이 깨지게된다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들은 __shift__ 해줘야 하는 비용이 발생하고 이 시간복잡도는 O(n)이 된다. 삽입도 마찬가지로 인덱스를 모두 1씩 __shift__ 하기 때문에 O(n)의 시간복잡도를 갖는다.

2. Linked List

   - 위의 문제점을 해결하기 위한 자료구조이다. 원소들은 각각 자기 다음에 어떤 원소인지만 기억하고있다. 그렇기 때문에 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)만에 해결이 가능.
   - 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어 첫번째 원소부터 다 확인을 해야하는 문제점이 있다. 논리적 저장 순서와 물리적 저장 순서가 다르기 때문. 따라서 원소를 삭제 또는 추가 할때 그 원소를 찾기 위해 O(n)의 시간이 추가적으로 발생한다.
   - 따라서 Search에 O(n)을 갖고, 삽입 삭제에도 O(n)의 복잡도를 갖는다. 이 구조는 Tree 구조의 근간이 되는 자료이기에 Tree에서 사용될때 유용성이 드러남.

   #### Personal Recommendation

   - Array 를 기반으로한 Linked List 구현
   - ArrayList 를 기반으로한 Linked List 구현



# Stack & Queue

1. Stack
   - 선형 자료구조의 일종으로 __Last In First Out (LIFO)__. 나중에 들어간 원소가 먼저나오는 특징을 갖는다. 
2. Queue
   - 선형 자료구조의 일종으로 __First In First Out (FIFO)__. 먼저 들어간 원소가 먼저나오는 특징을 갖는다. 
   - 참고로 Java Collection에서 Queue는 인터페이스이다. 이를 구현하고 있는 우선순위 큐(Priority queue) 등을 사용할 수 있다. // 우선순위 큐 => 우선순위가 높은 원소가 먼저나옴

#### Personal Recommendation

- Stack 을 사용하여 미로찾기 구현하기
- Queue 를 사용하여 Heap 자료구조 구현하기
- Stack 두 개로 Queue 자료구조 구현하기
- Stack 으로 괄호 유효성 체크 코드 구현하기



# Tree

트리는 비선형 자료구조이다. 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. 트리라는 자료구조는 표현에 집중한다. 

#### 트리를 구성하고 있는 구성요소들(용어)

- Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미
- Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미
- Terminal Node( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않는 노드를 의미
- Internal Node(내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함



#### Binary Tree (이진 트리)

- 루트 노드를 중심으로 두 개 의 서브트리로 나뉘어 진다. 또한 나뉘어진 두 서브 트리도 모두 이진 트리어야 한다. 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf node 에 다다랐을 때, 정의가 만족되기 때문.
- 트리에서는 각 층별로 숫자를 매겨서 이를 트리의 __level(레벨)__ 이라고 한다. 레벨의 값은 0부터 시작하고 다라서 루트 노드의 레벨은 0이다. 트리의 최고 레벨을 가리켜 해당 트리의 __height(높이)__ 라고 한다.
- Perfect Binary Tree (포화 이진 트리), Complete Binary Tree (완전 이진 트리), Full Binary Tree (정 이진 트리)
  - 모든 레벨이 꽉찬 이진트리 = 포화 이진트리
  - 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리 = 완전 이진 트리
  - 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진트리 = 정 이진 트리
  - 이진트리에서 노드의 갯수가 n개 root가 0이 아닌 1에서 시작할 때 , i 번째 노드에 대해서 parent(i) = i / 2, left_child(i) = 2i , right_child(i) = 2i + 1의 index 값을 갖는다.

#### BST (Binary Search Tree)

효율적인 탐색을 위해서는 어떻게 찾을까 고민보다 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종으로 데이터를 저장하는 규칙이있고 이 규칙은 특정 데이터를 찾는데 사용가능하다.

- 규칙 1 : 이진 탐색 트리의 노드에 저장된 키는 유일함
- 규칙 2 : 부모의 키가 왼쪽 자식 노드의 키보다 크다.
- 규칙 3 : 부모의 키가 오른쪽 자식 노드의 키보다 작다.
- 규칙 4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖음. 좀 더 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문!! 하지만 이러한 이진 탐색 트리는 편향트리(Skewed Tree)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문!! 이럴 경우 탐색의 Worst case가 되고 시간 복잡도는 O(n)이 된다.

배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비 효율적인 상황이 발생하는데 이를 해길하기 위해 __Rebalancing__ 기법이 등장. 균형을 잡기 위한 트리 구조의 재조정을 __Rebalancing__ 이라한다. 이 기법을 구현한 트리는 여러 종류가 있는데 그 중 하나가 __Red-Black Tree__ 이다.



#### Personal Recommendation

- Binary Search Tree 구현하기
- 주어진 트리가 Binary 트리인지 확인하는 알고리즘 구현하기

